# 内存管理代码参考

## 1. SafeMemoryHandle类
```csharp
/// <summary>
/// 安全内存句柄类，用于管理非托管资源
/// </summary>
public class SafeMemoryHandle : SafeHandle
{
    /// <summary>
    /// 构造函数
    /// </summary>
    private SafeMemoryHandle() : base(IntPtr.Zero, true) { }
    
    /// <summary>
    /// 获取句柄是否无效
    /// </summary>
    public override bool IsInvalid => handle == IntPtr.Zero;
    
    /// <summary>
    /// 释放句柄资源
    /// </summary>
    /// <returns>释放是否成功</returns>
    protected override bool ReleaseHandle()
    {
        if (handle != IntPtr.Zero)
        {
            Marshal.FreeHGlobal(handle);
            handle = IntPtr.Zero;
        }
        return true;
    }
}
```

## 2. 内存管理助手类
```csharp
/// <summary>
/// 内存管理助手类
/// </summary>
public static class MemoryHelper
{
    /// <summary>
    /// 分配内存
    /// </summary>
    /// <param name="size">内存大小</param>
    /// <returns>内存指针</returns>
    public static IntPtr Allocate(int size)
    {
        IntPtr ptr = Marshal.AllocHGlobal(size);
        // 记录内存分配
        LogHelper.Debug($"Allocated {size} bytes at 0x{ptr.ToInt64():X}", "Memory");
        return ptr;
    }
    
    /// <summary>
    /// 释放内存
    /// </summary>
    /// <param name="ptr">内存指针</param>
    public static void Free(IntPtr ptr)
    {
        if (ptr != IntPtr.Zero)
        {
            Marshal.FreeHGlobal(ptr);
            // 记录内存释放
            LogHelper.Debug($"Freed memory at 0x{ptr.ToInt64():X}", "Memory");
        }
    }
}
```

## 3. Hook回调函数内存管理示例
```csharp
/// <summary>
/// GetSystemInfo API 回调函数
/// </summary>
/// <param name="lpSystemInfo">系统信息结构体</param>
private static void GetSystemInfo_Detour(out NativeApi.SYSTEM_INFO lpSystemInfo)
{
    // 先调用原始API，获取真实信息
    _origGetSystemInfo(out lpSystemInfo);
    
    try
    {
        // 检查是否在Capture模式
        if (CaptureStore.IsCaptureMode)
        {
            // 记录原始值
            var obj = new { dwNumberOfProcessors = lpSystemInfo.dwNumberOfProcessors };
            CaptureStore.Record(IdentityGetSystemInfo, "Win32", "kernel32.dll", "GetSystemInfo", null, obj);
            return;
        }
        
        // 检查是否在Replay模式
        if (CaptureStore.IsReplayMode)
        {
            // 从记录中获取值并应用
            if (CaptureStore.TryGetReplaceValue(IdentityGetSystemInfo, out var token))
            {
                ApplySystemInfoToken(token, ref lpSystemInfo);
                return;
            }
        }
        
        // 应用配置中的值
        if (_config?.Cpu != null)
        {
            lpSystemInfo.dwNumberOfProcessors = (uint)Math.Max(1, _config.Cpu.CoreCount);
        }
    }
    catch (Exception ex)
    {
        // 异常处理，确保目标进程不崩溃
        LogHelper.Write("GetSystemInfo_Detour 异常: " + ex.Message);
    }
}
```