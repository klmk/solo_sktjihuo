# 注入管理代码参考

## 1. 注入结果类
```csharp
/// <summary>
/// 注入结果类
/// </summary>
public class InjectResult
{
    /// <summary>
    /// 是否成功
    /// </summary>
    public bool Success { get; }
    
    /// <summary>
    /// 消息
    /// </summary>
    public string Message { get; }
    
    /// <summary>
    /// 卸载事件名称
    /// </summary>
    public string UnloadEventName { get; }
    
    /// <summary>
    /// 构造函数
    /// </summary>
    /// <param name="success">是否成功</param>
    /// <param name="message">消息</param>
    /// <param name="unloadEventName">卸载事件名称</param>
    private InjectResult(bool success, string message, string unloadEventName = null)
    {
        Success = success;
        Message = message;
        UnloadEventName = unloadEventName;
    }
    
    /// <summary>
    /// 创建成功结果
    /// </summary>
    /// <param name="unloadEventName">卸载事件名称</param>
    /// <returns>成功结果</returns>
    public static InjectResult Ok(string unloadEventName)
    {
        return new InjectResult(true, "注入成功", unloadEventName);
    }
    
    /// <summary>
    /// 创建失败结果
    /// </summary>
    /// <param name="message">失败消息</param>
    /// <returns>失败结果</returns>
    public static InjectResult Fail(string message)
    {
        return new InjectResult(false, message);
    }
}
```

## 2. 注入管理器类
```csharp
/// <summary>
/// 注入管理器类
/// </summary>
public class InjectionManager
{
    private static readonly object _lock = new object();
    private static readonly HashSet<int> _injectedProcesses = new HashSet<int>();
    
    /// <summary>
    /// 注入目标进程
    /// </summary>
    /// <param name="processId">进程ID</param>
    /// <param name="configPath">配置文件路径</param>
    /// <returns>注入结果</returns>
    public static InjectResult Inject(int processId, string configPath)
    {
        lock (_lock)
        {
            // 检查是否已注入
            if (_injectedProcesses.Contains(processId))
            {
                return InjectResult.Fail("目标进程已注入");
            }
            
            // 验证目标进程
            if (!ProcessAlive(processId))
            {
                return InjectResult.Fail("目标进程不存在或已退出");
            }
            
            // 验证配置文件
            if (string.IsNullOrWhiteSpace(configPath) || !File.Exists(configPath))
            {
                return InjectResult.Fail("配置文件无效");
            }
            
            try
            {
                ConfigManager.Validate(ConfigManager.Load(configPath));
            }
            catch (Exception ex)
            {
                return InjectResult.Fail("配置文件格式错误：" + ex.Message);
            }
            
            // 解析核心DLL路径
            string dllPath = ResolveCoreDllPath();
            if (string.IsNullOrEmpty(dllPath))
            {
                return InjectResult.Fail("找不到 Hook 核心 DLL");
            }
            
            // 生成卸载事件名称
            string unloadEventName = "HardwareHook_Unload_" + processId;
            
            try
            {
                // 执行注入
                RemoteHooking.Inject(
                    processId,
                    InjectionOptions.Default,
                    dllPath,
                    dllPath,
                    configPath,
                    unloadEventName
                );
                
                // 记录已注入进程
                _injectedProcesses.Add(processId);
                LogHelper.Info($"成功注入进程 {processId}", "Injection");
                
                return InjectResult.Ok(unloadEventName);
            }
            catch (Exception ex)
            {
                string errorMessage = $"注入失败：{ex.Message}";
                LogHelper.Error(errorMessage, "Injection");
                
                // 分类错误类型
                if (ex.Message.Contains("拒绝访问"))
                {
                    return InjectResult.Fail("注入失败：权限不足，请以管理员身份运行");
                }
                else if (ex.Message.Contains("无法打开进程"))
                {
                    return InjectResult.Fail("注入失败：无法打开进程，可能是系统进程或权限不足");
                }
                else if (ex.Message.Contains("32位") || ex.Message.Contains("64位"))
                {
                    return InjectResult.Fail("注入失败：进程位数与DLL不匹配");
                }
                else
                {
                    return InjectResult.Fail(errorMessage);
                }
            }
        }
    }
    
    /// <summary>
    /// 停止模拟
    /// </summary>
    /// <param name="processId">进程ID</param>
    public static void StopSimulation(int processId)
    {
        lock (_lock)
        {
            string evtName = "HardwareHook_Unload_" + processId;
            try
            {
                using (var evt = new EventWaitHandle(false, EventResetMode.ManualReset, evtName))
                {
                    evt.Set();
                }
                _injectedProcesses.Remove(processId);
                LogHelper.Info($"成功停止进程 {processId} 的模拟", "Injection");
            }
            catch (Exception ex)
            {
                LogHelper.Error($"停止模拟失败：{ex.Message}", "Injection");
            }
        }
    }
    
    /// <summary>
    /// 检查进程是否存活
    /// </summary>
    /// <param name="processId">进程ID</param>
    /// <returns>进程是否存活</returns>
    private static bool ProcessAlive(int processId)
    {
        try
        {
            Process.GetProcessById(processId);
            return true;
        }
        catch
        {
            return false;
        }
    }
    
    /// <summary>
    /// 解析核心DLL路径
    /// </summary>
    /// <returns>核心DLL路径</returns>
    private static string ResolveCoreDllPath()
    {
        string baseDir = AppDomain.CurrentDomain.BaseDirectory;
        string dllPath = Path.Combine(baseDir, "HardwareHook.Core.dll");
        
        if (File.Exists(dllPath))
        {
            return dllPath;
        }
        
        // 尝试其他可能的路径
        string[] possiblePaths = {
            Path.Combine(baseDir, "bin", "Debug", "HardwareHook.Core.dll"),
            Path.Combine(baseDir, "bin", "Release", "HardwareHook.Core.dll")
        };
        
        foreach (string path in possiblePaths)
        {
            if (File.Exists(path))
            {
                return path;
            }
        }
        
        return null;
    }
}
```

## 3. w3wp.exe注入优化
```csharp
/// <summary>
/// w3wp.exe注入优化类
/// </summary>
public static class W3wpInjector
{
    /// <summary>
    /// 注入w3wp.exe进程
    /// </summary>
    /// <param name="processId">进程ID</param>
    /// <param name="configPath">配置文件路径</param>
    /// <returns>注入结果</returns>
    public static InjectResult InjectW3wp(int processId, string configPath)
    {
        // 验证进程是否为w3wp.exe
        Process process;
        try
        {
            process = Process.GetProcessById(processId);
            if (!IsW3wpProcess(process))
            {
                return InjectResult.Fail("目标进程不是w3wp.exe");
            }
        }
        catch
        {
            return InjectResult.Fail("无法获取进程信息");
        }
        
        // 记录应用池名称
        string appPoolName = GetAppPoolName(process);
        LogHelper.Write("注入w3wp.exe进程，应用池：" + appPoolName);
        
        // 执行注入
        return InjectionManager.Inject(processId, configPath);
    }
    
    /// <summary>
    /// 检查是否为w3wp.exe进程
    /// </summary>
    /// <param name="process">进程对象</param>
    /// <returns>是否为w3wp.exe进程</returns>
    private static bool IsW3wpProcess(Process process)
    {
        return process.ProcessName.Equals("w3wp", StringComparison.OrdinalIgnoreCase);
    }
    
    /// <summary>
    /// 获取应用池名称
    /// </summary>
    /// <param name="process">进程对象</param>
    /// <returns>应用池名称</returns>
    private static string GetAppPoolName(Process process)
    {
        try
        {
            // 通过命令行参数获取应用池名称
            foreach (var arg in process.StartInfo.Arguments.Split(' '))
            {
                if (arg.StartsWith("-ap"))
                {
                    return arg.Substring(3);
                }
            }
            return "Unknown";
        }
        catch
        {
            return "Unknown";
        }
    }
}
```