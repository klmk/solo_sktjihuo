# Buddy_Codeä»£ç ä¿®å¤æ–¹æ¡ˆ

**ä¿®å¤ç›®æ ‡**: è§£å†³å®¡è®¡æŠ¥å‘Šä¸­å‘ç°çš„ä¸¥é‡é—®é¢˜ï¼Œä½¿ä»£ç æ»¡è¶³å¼€å‘æ–‡æ¡£è¦æ±‚
**ä¼˜å…ˆçº§**: é«˜ -> ä½

---

## ğŸ”´ ç«‹å³ä¿®å¤é¡¹ï¼ˆé˜»å¡æ€§ï¼‰

### 1. ä¿®å¤HookManagerçš„thiså¼•ç”¨é”™è¯¯

**é—®é¢˜**: HookManageræ˜¯é™æ€ç±»ï¼Œä½†åœ¨Hookåˆ›å»ºæ—¶ä¼ é€’äº†thisæŒ‡é’ˆ

**ä¿®å¤æ–¹æ¡ˆ**: å°†HookManageræ”¹ä¸ºå®ä¾‹ç±»

#### ä¿®æ”¹åçš„HardwareHook.Core/Hook/HookManager.cs

```csharp
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using EasyHook;
using HardwareHook.Core.Config;
using HardwareHook.Core.Logging;
using HardwareHook.Core.Native;

namespace HardwareHook.Core.Hook
{
    /// <summary>
    /// Hookç®¡ç†å™¨ï¼ˆå®ä¾‹ç±»ï¼‰
    /// </summary>
    public class HookManager : IDisposable
    {
        private readonly object _lock = new object();
        private readonly List<LocalHook> _hooks = new List<LocalHook>();
        private bool _isInitialized = false;
        private HardwareConfig _config;
        
        // å•ä¾‹æ¨¡å¼ç¡®ä¿å…¨å±€å”¯ä¸€
        private static HookManager _instance;
        private static readonly object _instanceLock = new object();
        
        public static HookManager Instance
        {
            get
            {
                lock (_instanceLock)
                {
                    if (_instance == null)
                    {
                        _instance = new HookManager();
                    }
                    return _instance;
                }
            }
        }
        
        private HookManager() { }
        
        /// <summary>
        /// å®‰è£…æ‰€æœ‰Hook
        /// </summary>
        public void InstallAll(HardwareConfig config)
        {
            lock (_lock)
            {
                if (_isInitialized)
                {
                    Logger.Warning("Hookå·²ç»åˆå§‹åŒ–ï¼Œè·³è¿‡", "HookManager");
                    return;
                }
                
                _config = config ?? throw new ArgumentNullException(nameof(config));
                
                try
                {
                    // å®‰è£…CPUä¿¡æ¯Hook
                    InstallCpuHooks();
                    
                    // å®‰è£…ç¡¬ç›˜ä¿¡æ¯Hook
                    InstallDiskHooks();
                    
                    // å®‰è£…MACåœ°å€Hookï¼ˆå¢å¼ºç‰ˆï¼‰
                    InstallMacHooks();
                    
                    // å®‰è£…ä¸»æ¿ä¿¡æ¯Hookï¼ˆå¢å¼ºç‰ˆï¼‰
                    InstallMotherboardHooks();
                    
                    _isInitialized = true;
                    Logger.Info("æ‰€æœ‰Hookå®‰è£…æˆåŠŸ", "HookManager");
                }
                catch (Exception ex)
                {
                    Logger.Error($"Hookå®‰è£…å¤±è´¥: {ex.Message}", "HookManager");
                    throw;
                }
            }
        }
        
        /// <summary>
        /// å¸è½½æ‰€æœ‰Hook
        /// </summary>
        public void UninstallAll()
        {
            lock (_lock)
            {
                foreach (var hook in _hooks)
                {
                    try
                    {
                        hook.Dispose();
                    }
                    catch (Exception ex)
                    {
                        Logger.Error($"Hookå¸è½½å¤±è´¥: {ex.Message}", "HookManager");
                    }
                }
                
                _hooks.Clear();
                _isInitialized = false;
                Logger.Info("æ‰€æœ‰Hookå·²å¸è½½", "HookManager");
            }
        }
        
        public void Dispose()
        {
            UninstallAll();
        }
        
        #region CPU Hook
        
        private void InstallCpuHooks()
        {
            try
            {
                var hook1 = LocalHook.Create(
                    LocalHook.GetProcAddress("kernel32.dll", "GetSystemInfo"),
                    new GetSystemInfoDelegate(GetSystemInfo_Hooked),
                    this);  // ç°åœ¨thisæ˜¯æœ‰æ•ˆçš„å®ä¾‹å¼•ç”¨
                hook1.ThreadACL.SetInclusiveACL(new int[] { 0 });
                _hooks.Add(hook1);
                
                var hook2 = LocalHook.Create(
                    LocalHook.GetProcAddress("kernel32.dll", "GetNativeSystemInfo"),
                    new GetNativeSystemInfoDelegate(GetNativeSystemInfo_Hooked),
                    this);
                hook2.ThreadACL.SetInclusiveACL(new int[] { 0 });
                _hooks.Add(hook2);
                
                Logger.Info("CPUä¿¡æ¯Hookå®‰è£…æˆåŠŸ", "HookManager");
            }
            catch (Exception ex)
            {
                Logger.Error($"CPUä¿¡æ¯Hookå®‰è£…å¤±è´¥: {ex.Message}", "HookManager");
                throw;
            }
        }
        
        private void GetSystemInfo_Hooked(out NativeApi.SYSTEM_INFO lpSystemInfo)
        {
            try
            {
                NativeApi.GetSystemInfo(out lpSystemInfo);
                
                if (_config?.Cpu != null && _config.Cpu.CoreCount > 0)
                {
                    lpSystemInfo.dwNumberOfProcessors = (uint)_config.Cpu.CoreCount;
                }
                
                Logger.Debug($"GetSystemInfo Hooked: CoreCount={lpSystemInfo.dwNumberOfProcessors}", "HookManager");
            }
            catch (Exception ex)
            {
                Logger.Error($"GetSystemInfo Hookå¼‚å¸¸: {ex.Message}", "HookManager");
                NativeApi.GetSystemInfo(out lpSystemInfo);
            }
        }
        
        private void GetNativeSystemInfo_Hooked(out NativeApi.SYSTEM_INFO lpSystemInfo)
        {
            try
            {
                NativeApi.GetNativeSystemInfo(out lpSystemInfo);
                
                if (_config?.Cpu != null && _config.Cpu.CoreCount > 0)
                {
                    lpSystemInfo.dwNumberOfProcessors = (uint)_config.Cpu.CoreCount;
                }
                
                Logger.Debug($"GetNativeSystemInfo Hooked: CoreCount={lpSystemInfo.dwNumberOfProcessors}", "HookManager");
            }
            catch (Exception ex)
            {
                Logger.Error($"GetNativeSystemInfo Hookå¼‚å¸¸: {ex.Message}", "HookManager");
                NativeApi.GetNativeSystemInfo(out lpSystemInfo);
            }
        }
        
        #endregion
        
        #region Disk Hook
        
        private void InstallDiskHooks()
        {
            try
            {
                var hook = LocalHook.Create(
                    LocalHook.GetProcAddress("kernel32.dll", "GetVolumeInformationW"),
                    new GetVolumeInformationWDelegate(GetVolumeInformationW_Hooked),
                    this);
                hook.ThreadACL.SetInclusiveACL(new int[] { 0 });
                _hooks.Add(hook);
                
                Logger.Info("ç¡¬ç›˜ä¿¡æ¯Hookå®‰è£…æˆåŠŸ", "HookManager");
            }
            catch (Exception ex)
            {
                Logger.Error($"ç¡¬ç›˜ä¿¡æ¯Hookå®‰è£…å¤±è´¥: {ex.Message}", "HookManager");
                throw;
            }
        }
        
        private bool GetVolumeInformationW_Hooked(
            string lpRootPathName,
            IntPtr lpVolumeNameBuffer,
            int nVolumeNameSize,
            out uint lpVolumeSerialNumber,
            out uint lpMaximumComponentLength,
            out uint lpFileSystemFlags,
            IntPtr lpFileSystemNameBuffer,
            int nFileSystemNameSize)
        {
            try
            {
                bool result = NativeApi.GetVolumeInformationW(
                    lpRootPathName,
                    lpVolumeNameBuffer,
                    nVolumeNameSize,
                    out lpVolumeSerialNumber,
                    out lpMaximumComponentLength,
                    out lpFileSystemFlags,
                    lpFileSystemNameBuffer,
                    nFileSystemNameSize);
                
                if (result && _config?.Disk != null && !string.IsNullOrEmpty(_config.Disk.Serial))
                {
                    // æ”¹è¿›çš„åºåˆ—å·è½¬æ¢
                    if (uint.TryParse(_config.Disk.Serial, System.Globalization.NumberStyles.HexNumber, 
                        null, out uint serial))
                    {
                        lpVolumeSerialNumber = serial;
                    }
                    else
                    {
                        // ä½¿ç”¨å“ˆå¸Œç®—æ³•ç”Ÿæˆ32ä½åºåˆ—å·
                        lpVolumeSerialNumber = (uint)_config.Disk.Serial.GetHashCode();
                    }
                }
                
                Logger.Debug($"GetVolumeInformationW Hooked: Serial={lpVolumeSerialNumber:X}", "HookManager");
                return result;
            }
            catch (Exception ex)
            {
                Logger.Error($"GetVolumeInformationW Hookå¼‚å¸¸: {ex.Message}", "HookManager");
                return NativeApi.GetVolumeInformationW(
                    lpRootPathName,
                    lpVolumeNameBuffer,
                    nVolumeNameSize,
                    out lpVolumeSerialNumber,
                    out lpMaximumComponentLength,
                    out lpFileSystemFlags,
                    lpFileSystemNameBuffer,
                    nFileSystemNameSize);
            }
        }
        
        #endregion
        
        #region MAC Hook
        
        private void InstallMacHooks()
        {
            try
            {
                // Hookä¼ ç»ŸAPI
                var hook1 = LocalHook.Create(
                    LocalHook.GetProcAddress("iphlpapi.dll", "GetAdaptersInfo"),
                    new GetAdaptersInfoDelegate(GetAdaptersInfo_Hooked),
                    this);
                hook1.ThreadACL.SetInclusiveACL(new int[] { 0 });
                _hooks.Add(hook1);
                
                // Hookç°ä»£APIï¼ˆæ›´é‡è¦ï¼‰
                var hook2 = LocalHook.Create(
                    LocalHook.GetProcAddress("iphlpapi.dll", "GetAdaptersAddresses"),
                    new GetAdaptersAddressesDelegate(GetAdaptersAddresses_Hooked),
                    this);
                hook2.ThreadACL.SetInclusiveACL(new int[] { 0 });
                _hooks.Add(hook2);
                
                Logger.Info("MACåœ°å€Hookå®‰è£…æˆåŠŸ", "HookManager");
            }
            catch (Exception ex)
            {
                Logger.Error($"MACåœ°å€Hookå®‰è£…å¤±è´¥: {ex.Message}", "HookManager");
                throw;
            }
        }
        
        private int GetAdaptersInfo_Hooked(IntPtr pAdapterInfo, ref int pOutBufLen)
        {
            try
            {
                int result = NativeApi.GetAdaptersInfo(pAdapterInfo, ref pOutBufLen);
                
                if (result == 0 && pAdapterInfo != IntPtr.Zero && _config?.Mac != null && 
                    !string.IsNullOrEmpty(_config.Mac.Address))
                {
                    ModifyAdapterInfo(pAdapterInfo);
                }
                
                return result;
            }
            catch (Exception ex)
            {
                Logger.Error($"GetAdaptersInfo Hookå¼‚å¸¸: {ex.Message}", "HookManager");
                return NativeApi.GetAdaptersInfo(pAdapterInfo, ref pOutBufLen);
            }
        }
        
        private void ModifyAdapterInfo(IntPtr pAdapterInfo)
        {
            try
            {
                string[] macParts = _config.Mac.Address.Split(':', '-');
                if (macParts.Length != 6) return;
                
                byte[] macBytes = new byte[6];
                for (int i = 0; i < 6; i++)
                {
                    macBytes[i] = Convert.ToByte(macParts[i], 16);
                }
                
                // éå†é“¾è¡¨ä¿®æ”¹æ‰€æœ‰é€‚é…å™¨
                IntPtr current = pAdapterInfo;
                while (current != IntPtr.Zero)
                {
                    var adapterInfo = Marshal.PtrToStructure<NativeApi.IP_ADAPTER_INFO>(current);
                    adapterInfo.Address = macBytes;
                    adapterInfo.AddressLength = 6;
                    Marshal.StructureToPtr(adapterInfo, current, false);
                    
                    current = adapterInfo.Next;
                }
                
                Logger.Debug($"GetAdaptersInfo Hooked: MAC={_config.Mac.Address}", "HookManager");
            }
            catch (Exception ex)
            {
                Logger.Warning($"MACåœ°å€ä¿®æ”¹å¤±è´¥: {ex.Message}", "HookManager");
            }
        }
        
        private int GetAdaptersAddresses_Hooked(
            uint family,
            uint flags,
            IntPtr reserved,
            IntPtr adapters,
            ref uint size)
        {
            try
            {
                int result = NativeApi.GetAdaptersAddresses(family, flags, reserved, adapters, ref size);
                
                if (result == 0 && adapters != IntPtr.Zero && _config?.Mac != null && 
                    !string.IsNullOrEmpty(_config.Mac.Address))
                {
                    ModifyAdapterAddresses(adapters);
                }
                
                return result;
            }
            catch (Exception ex)
            {
                Logger.Error($"GetAdaptersAddresses Hookå¼‚å¸¸: {ex.Message}", "HookManager");
                return NativeApi.GetAdaptersAddresses(family, flags, reserved, adapters, ref size);
            }
        }
        
        private void ModifyAdapterAddresses(IntPtr adapters)
        {
            try
            {
                // è§£æMACåœ°å€
                string[] macParts = _config.Mac.Address.Split(':', '-');
                if (macParts.Length != 6) return;
                
                // éå†é“¾è¡¨ä¿®æ”¹æ‰€æœ‰é€‚é…å™¨
                IntPtr current = adapters;
                while (current != IntPtr.Zero)
                {
                    // ä¿®æ”¹é€‚é…å™¨åœ°å€ï¼ˆéœ€è¦æ ¹æ®å®é™…ç»“æ„ä½“å®šä¹‰ï¼‰
                    // ...
                    
                    // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªé€‚é…å™¨
                    var adapterAddr = Marshal.PtrToStructure<NativeApi.IP_ADAPTER_ADDRESSES>(current);
                    current = adapterAddr.Next;
                }
                
                Logger.Debug($"GetAdaptersAddresses Hooked: MAC={_config.Mac.Address}", "HookManager");
            }
            catch (Exception ex)
            {
                Logger.Warning($"é€‚é…å™¨åœ°å€ä¿®æ”¹å¤±è´¥: {ex.Message}", "HookManager");
            }
        }
        
        #endregion
        
        #region Motherboard Hook
        
        private void InstallMotherboardHooks()
        {
            try
            {
                var hook1 = LocalHook.Create(
                    LocalHook.GetProcAddress("advapi32.dll", "RegOpenKeyExW"),
                    new RegOpenKeyExWDelegate(RegOpenKeyExW_Hooked),
                    this);
                hook1.ThreadACL.SetInclusiveACL(new int[] { 0 });
                _hooks.Add(hook1);
                
                var hook2 = LocalHook.Create(
                    LocalHook.GetProcAddress("advapi32.dll", "RegQueryValueExW"),
                    new RegQueryValueExWDelegate(RegQueryValueExW_Hooked),
                    this);
                hook2.ThreadACL.SetInclusiveACL(new int[] { 0 });
                _hooks.Add(hook2);
                
                Logger.Info("ä¸»æ¿ä¿¡æ¯Hookå®‰è£…æˆåŠŸ", "HookManager");
            }
            catch (Exception ex)
            {
                Logger.Error($"ä¸»æ¿ä¿¡æ¯Hookå®‰è£…å¤±è´¥: {ex.Message}", "HookManager");
                throw;
            }
        }
        
        private int RegOpenKeyExW_Hooked(
            IntPtr hKey,
            string lpSubKey,
            uint ulOptions,
            uint samDesired,
            out IntPtr phkResult)
        {
            try
            {
                int result = NativeApi.RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, out phkResult);
                
                // å¯ä»¥åœ¨è¿™é‡Œç¼“å­˜éœ€è¦æ¨¡æ‹Ÿçš„æ³¨å†Œè¡¨é¡¹
                if (lpSubKey != null && IsMotherboardRegistryKey(lpSubKey))
                {
                    Logger.Debug($"RegOpenKeyExW Hooked: {lpSubKey}", "HookManager");
                }
                
                return result;
            }
            catch (Exception ex)
            {
                Logger.Error($"RegOpenKeyExW Hookå¼‚å¸¸: {ex.Message}", "HookManager");
                return NativeApi.RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, out phkResult);
            }
        }
        
        private int RegQueryValueExW_Hooked(
            IntPtr hKey,
            string lpValueName,
            IntPtr lpReserved,
            out uint lpType,
            IntPtr lpData,
            ref uint lpcbData)
        {
            try
            {
                int result = NativeApi.RegQueryValueExW(hKey, lpValueName, lpReserved, out lpType, lpData, ref lpcbData);
                
                if (result == 0 && ShouldSimulateMotherboardInfo(lpValueName) && _config?.Motherboard != null)
                {
                    SimulateMotherboardValue(lpValueName, lpData, ref lpcbData, lpType);
                }
                
                return result;
            }
            catch (Exception ex)
            {
                Logger.Error($"RegQueryValueExW Hookå¼‚å¸¸: {ex.Message}", "HookManager");
                return NativeApi.RegQueryValueExW(hKey, lpValueName, lpReserved, out lpType, lpData, ref lpcbData);
            }
        }
        
        private bool IsMotherboardRegistryKey(string subKey)
        {
            if (string.IsNullOrEmpty(subKey)) return false;
            
            return subKey.Contains("SYSTEM\\CurrentControlSet\\Enum") ||
                   subKey.Contains("HARDWARE\\DESCRIPTION\\System") ||
                   subKey.Contains("SYSTEM\\CurrentControlSet\\Control\\SystemInformation");
        }
        
        private bool ShouldSimulateMotherboardInfo(string valueName)
        {
            if (string.IsNullOrEmpty(valueName)) return false;
            
            string[] simulatedValues = {
                "SystemBiosVersion",
                "SystemBiosDate", 
                "SystemProductName",
                "SystemManufacturer",
                "BaseBoardProduct",
                "BaseBoardManufacturer",
                "BaseBoardSerial"
            };
            
            return simulatedValues.Any(v => valueName.Equals(v, StringComparison.OrdinalIgnoreCase));
        }
        
        private void SimulateMotherboardValue(string valueName, IntPtr lpData, ref uint lpcbData, uint lpType)
        {
            try
            {
                string simulatedValue = GetSimulatedMotherboardValue(valueName);
                if (string.IsNullOrEmpty(simulatedValue)) return;
                
                byte[] valueBytes;
                
                if (lpType == 1) // REG_SZ
                {
                    valueBytes = Encoding.Unicode.GetBytes(simulatedValue + "\0");
                }
                else // REG_MULTI_SZ, REG_BINARYç­‰
                {
                    valueBytes = Encoding.ASCII.GetBytes(simulatedValue + "\0");
                }
                
                if (lpcbData >= valueBytes.Length)
                {
                    Marshal.Copy(valueBytes, 0, lpData, valueBytes.Length);
                    lpcbData = (uint)valueBytes.Length;
                    
                    Logger.Debug($"RegQueryValueExW Hooked: {valueName} = {simulatedValue}", "HookManager");
                }
            }
            catch (Exception ex)
            {
                Logger.Warning($"ä¸»æ¿ä¿¡æ¯æ¨¡æ‹Ÿå¤±è´¥: {ex.Message}", "HookManager");
            }
        }
        
        private string GetSimulatedMotherboardValue(string valueName)
        {
            if (_config?.Motherboard == null) return null;
            
            return valueName.ToUpperInvariant() switch
            {
                "BASEBOARDSERIAL" => _config.Motherboard.Serial,
                "SYSTEMPRODUCTNAME" => "Simulated Motherboard",
                "SYSTEMMANUFACTURER" => "Simulated Manufacturer",
                _ => null
            };
        }
        
        #endregion
        
        #region å§”æ‰˜å®šä¹‰
        
        [UnmanagedFunctionPointer(CallingConvention.Winapi)]
        private delegate void GetSystemInfoDelegate(out NativeApi.SYSTEM_INFO lpSystemInfo);
        
        [UnmanagedFunctionPointer(CallingConvention.Winapi)]
        private delegate void GetNativeSystemInfoDelegate(out NativeApi.SYSTEM_INFO lpSystemInfo);
        
        [UnmanagedFunctionPointer(CallingConvention.Winapi, CharSet = CharSet.Unicode)]
        private delegate bool GetVolumeInformationWDelegate(
            string lpRootPathName,
            IntPtr lpVolumeNameBuffer,
            int nVolumeNameSize,
            out uint lpVolumeSerialNumber,
            out uint lpMaximumComponentLength,
            out uint lpFileSystemFlags,
            IntPtr lpFileSystemNameBuffer,
            int nFileSystemNameSize);
        
        [UnmanagedFunctionPointer(CallingConvention.Winapi)]
        private delegate int GetAdaptersInfoDelegate(IntPtr pAdapterInfo, ref int pOutBufLen);
        
        [UnmanagedFunctionPointer(CallingConvention.Winapi)]
        private delegate int GetAdaptersAddressesDelegate(
            uint family,
            uint flags,
            IntPtr reserved,
            IntPtr adapters,
            ref uint size);
        
        [UnmanagedFunctionPointer(CallingConvention.Winapi, CharSet = CharSet.Unicode)]
        private delegate int RegOpenKeyExWDelegate(
            IntPtr hKey,
            string lpSubKey,
            uint ulOptions,
            uint samDesired,
            out IntPtr phkResult);
        
        [UnmanagedFunctionPointer(CallingConvention.Winapi, CharSet = CharSet.Unicode)]
        private delegate int RegQueryValueExWDelegate(
            IntPtr hKey,
            string lpValueName,
            IntPtr lpReserved,
            out uint lpType,
            IntPtr lpData,
            ref uint lpcbData);
        
        #endregion
    }
}
```

---

### 2. å®ç°å¼‚æ­¥æ—¥å¿—ç³»ç»Ÿ

#### ä¿®æ”¹åçš„HardwareHook.Core/Logging/Logger.cs

```csharp
using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace HardwareHook.Core.Logging
{
    public enum LogLevel
    {
        Debug = 0,
        Info = 1,
        Warning = 2,
        Error = 3,
        Fatal = 4
    }
    
    public static class Logger
    {
        private static readonly BlockingCollection<LogEntry> _logQueue = new BlockingCollection<LogEntry>(10000);
        private static readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
        private static Task _writeTask;
        private static string _logDirectory;
        private static string _logFile;
        private static LogLevel _minLevel = LogLevel.Info;
        
        // ç»“æ„åŒ–æ—¥å¿—é…ç½®
        private static bool _enableStructuredLogging = false;
        private static string _operationId;
        
        public static void Initialize(string logDirectory, bool enableStructuredLogging = false)
        {
            _logDirectory = logDirectory;
            _enableStructuredLogging = enableStructuredLogging;
            
            try
            {
                Directory.CreateDirectory(logDirectory);
                
                string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                _logFile = Path.Combine(logDirectory, $"HardwareHook_{timestamp}.log");
                
                // å¯åŠ¨åå°å†™å…¥çº¿ç¨‹
                if (_writeTask == null || _writeTask.IsCompleted)
                {
                    _writeTask = Task.Factory.StartNew(
                        () => WriteLogs(_cancellationTokenSource.Token), 
                        TaskCreationOptions.LongRunning);
                }
                
                Info("æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ", "Logger");
            }
            catch (Exception ex)
            {
                Debug($"æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: {ex.Message}", "Logger");
            }
        }
        
        /// <summary>
        /// è®¾ç½®å½“å‰æ“ä½œIDï¼ˆç”¨äºè¿½è¸ªæ“ä½œé“¾ï¼‰
        /// </summary>
        public static void SetOperationId(string operationId)
        {
            _operationId = operationId;
        }
        
        private static void WriteLogs(CancellationToken token)
        {
            try
            {
                foreach (var entry in _logQueue.GetConsumingEnumerable(token))
                {
                    WriteLogSync(entry);
                }
            }
            catch (OperationCanceledException)
            {
                // æ­£å¸¸å–æ¶ˆ
            }
            catch (Exception ex)
            {
                Debug($"æ—¥å¿—å†™å…¥çº¿ç¨‹å¼‚å¸¸: {ex.Message}", "Logger");
            }
        }
        
        private static void WriteLogSync(LogEntry entry)
        {
            try
            {
                string logLine = _enableStructuredLogging ? 
                    FormatStructuredLog(entry) : 
                    FormatSimpleLog(entry);
                
                // å†™å…¥æ–‡ä»¶ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
                for (int i = 0; i < 3; i++)
                {
                    try
                    {
                        File.AppendAllText(_logFile, logLine + Environment.NewLine, Encoding.UTF8);
                        break;
                    }
                    catch (IOException) when (i < 2)
                    {
                        Thread.Sleep(10); // çŸ­æš‚ç­‰å¾…åé‡è¯•
                    }
                }
                
                // æ£€æŸ¥æ—¥å¿—æ–‡ä»¶å¤§å°ï¼Œè¶…è¿‡10MBåˆ™è½®è½¬
                CheckLogRotation();
            }
            catch
            {
                // æ—¥å¿—å†™å…¥å¤±è´¥ä¸åº”å½±å“ä¸»ç¨‹åº
            }
        }
        
        private static string FormatSimpleLog(LogEntry entry)
        {
            string timestamp = entry.Timestamp.ToString("yyyy-MM-dd HH:mm:ss.fff");
            string levelStr = entry.Level.ToString().ToUpper().PadRight(7);
            return $"[{timestamp}] [{levelStr}] [{entry.Module}] {entry.Message}" +
                   (string.IsNullOrEmpty(entry.Exception) ? "" : $"{Environment.NewLine}Exception: {entry.Exception}");
        }
        
        private static string FormatStructuredLog(LogEntry entry)
        {
            var logObject = new
            {
                timestamp = entry.Timestamp.ToString("yyyy-MM-ddTHH:mm:ss.fffZ"),
                level = entry.Level.ToString(),
                message = entry.Message,
                module = entry.Module,
                function = entry.Function,
                line = entry.Line,
                process_id = entry.ProcessId,
                process_name = entry.ProcessName,
                operation_id = entry.OperationId ?? _operationId,
                thread_id = entry.ThreadId,
                details = entry.Details,
                error_code = entry.ErrorCode,
                exception = entry.Exception,
                call_stack = entry.CallStack
            };
            
            return Newtonsoft.Json.JsonConvert.SerializeObject(logObject);
        }
        
        private static void CheckLogRotation()
        {
            try
            {
                var fileInfo = new FileInfo(_logFile);
                if (fileInfo.Exists && fileInfo.Length > 10 * 1024 * 1024) // 10MB
                {
                    string timestamp = DateTime.Now.ToString("HHmmss");
                    string backupPath = Path.Combine(_logDirectory, 
                        $"HardwareHook_{DateTime.Now:yyyyMMdd}_{timestamp}.log");
                    
                    File.Move(_logFile, backupPath);
                    
                    // æ¸…ç†æ—§æ—¥å¿—ï¼ˆä¿ç•™æœ€è¿‘7å¤©ï¼‰
                    CleanupOldLogs();
                }
            }
            catch
            {
                // è½®è½¬å¤±è´¥ä¸åº”å½±å“ä¸»ç¨‹åº
            }
        }
        
        private static void CleanupOldLogs()
        {
            try
            {
                var logFiles = Directory.GetFiles(_logDirectory, "HardwareHook_*.log");
                var cutoffDate = DateTime.Now.AddDays(-7);
                
                foreach (var file in logFiles)
                {
                    var fileInfo = new FileInfo(file);
                    if (fileInfo.CreationTime < cutoffDate)
                    {
                        try
                        {
                            File.Delete(file);
                        }
                        catch
                        {
                            // åˆ é™¤å¤±è´¥å¿½ç•¥
                        }
                    }
                }
            }
            catch
            {
                // æ¸…ç†å¤±è´¥ä¸åº”å½±å“ä¸»ç¨‹åº
            }
        }
        
        public static void SetMinLevel(LogLevel level)
        {
            _minLevel = level;
        }
        
        private static void EnqueueLog(LogLevel level, string message, string module, 
            string function = null, int line = 0, object details = null, int errorCode = 0)
        {
            if (level < _minLevel) return;
            
            var entry = new LogEntry
            {
                Timestamp = DateTime.Now,
                Level = level,
                Module = module,
                Message = message,
                Function = function,
                Line = line,
                ProcessId = Process.GetCurrentProcess().Id,
                ProcessName = Process.GetCurrentProcess().ProcessName,
                OperationId = _operationId,
                ThreadId = Thread.CurrentThread.ManagedThreadId,
                Details = details,
                ErrorCode = errorCode
            };
            
            // ä½¿ç”¨TryAddé¿å…é˜»å¡
            if (!_logQueue.TryAdd(entry))
            {
                // é˜Ÿåˆ—æ»¡æ—¶ç›´æ¥ä¸¢å¼ƒï¼Œé¿å…å½±å“æ€§èƒ½
            }
        }
        
        public static void Debug(string message, string module = "", 
            [System.Runtime.CompilerServices.CallerMemberName] string function = "",
            [System.Runtime.CompilerServices.CallerLineNumber] int line = 0)
        {
            EnqueueLog(LogLevel.Debug, message, module, function, line);
        }
        
        public static void Info(string message, string module = "",
            [System.Runtime.CompilerServices.CallerMemberName] string function = "",
            [System.Runtime.CompilerServices.CallerLineNumber] int line = 0)
        {
            EnqueueLog(LogLevel.Info, message, module, function, line);
        }
        
        public static void Warning(string message, string module = "",
            [System.Runtime.CompilerServices.CallerMemberName] string function = "",
            [System.Runtime.CompilerServices.CallerLineNumber] int line = 0)
        {
            EnqueueLog(LogLevel.Warning, message, module, function, line);
        }
        
        public static void Error(string message, string module = "", Exception ex = null,
            [System.Runtime.CompilerServices.CallerMemberName] string function = "",
            [System.Runtime.CompilerServices.CallerLineNumber] int line = 0)
        {
            EnqueueLog(LogLevel.Error, message, module, function, line, 
                details: ex?.Message, errorCode: ex?.HResult ?? 0);
        }
        
        public static void Fatal(string message, string module = "", Exception ex = null,
            [System.Runtime.CompilerServices.CallerMemberName] string function = "",
            [System.Runtime.CompilerServices.CallerLineNumber] int line = 0)
        {
            EnqueueLog(LogLevel.Fatal, message, module, function, line,
                details: ex?.Message, errorCode: ex?.HResult ?? 0);
        }
        
        /// <summary>
        /// åˆ·æ–°æ—¥å¿—ï¼ˆç¡®ä¿æ‰€æœ‰æ—¥å¿—å†™å…¥æ–‡ä»¶ï¼‰
        /// </summary>
        public static void Flush()
        {
            _logQueue.CompleteAdding();
            _writeTask?.Wait(TimeSpan.FromSeconds(2));
            _logQueue = new BlockingCollection<LogEntry>(10000);
            _writeTask = Task.Factory.StartNew(
                () => WriteLogs(_cancellationTokenSource.Token),
                TaskCreationOptions.LongRunning);
        }
    }
    
    internal class LogEntry
    {
        public DateTime Timestamp { get; set; }
        public LogLevel Level { get; set; }
        public string Module { get; set; }
        public string Message { get; set; }
        public string Function { get; set; }
        public int Line { get; set; }
        public int ProcessId { get; set; }
        public string ProcessName { get; set; }
        public string OperationId { get; set; }
        public int ThreadId { get; set; }
        public object Details { get; set; }
        public int ErrorCode { get; set; }
        public string Exception { get; set; }
        public string CallStack { get; set; }
    }
}
```

---

### 3. æ›´æ–°EntryPointä»¥ä½¿ç”¨HookManagerå•ä¾‹

#### ä¿®æ”¹åçš„HardwareHook.Core/EntryPoint.cs

```csharp
using System;
using System.IO;
using System.Threading;
using EasyHook;
using HardwareHook.Core.Config;
using HardwareHook.Core.Logging;

namespace HardwareHook.Core
{
    public class EntryPoint : IEntryPoint
    {
        private string _configPath;
        private string _unloadEventName;
        private EventWaitHandle _unloadEvent;
        private int _processId;
        
        public EntryPoint(RemoteHooking.IContext context, string channelName, string configPath, string unloadEventName)
        {
            _configPath = configPath;
            _unloadEventName = unloadEventName;
            _processId = RemoteHooking.GetCurrentProcessId();
            
            string logDir = Path.Combine(Path.GetDirectoryName(configPath) ?? AppDomain.CurrentDomain.BaseDirectory, "Logs");
            Logger.Initialize(logDir, enableStructuredLogging: true);
            
            Logger.Info($"EntryPointåˆå§‹åŒ–: PID={_processId}, Config={Path.GetFileName(configPath)}", "EntryPoint");
        }
        
        public void Run(RemoteHooking.IContext context, string channelName, string configPath, string unloadEventName)
        {
            try
            {
                Logger.Info("EntryPoint.Runå¼€å§‹æ‰§è¡Œ", "EntryPoint");
                Logger.SetOperationId(Guid.NewGuid().ToString());
                
                HardwareConfig config;
                try
                {
                    config = ConfigManager.Load(configPath);
                    Logger.Info("é…ç½®åŠ è½½æˆåŠŸ", "EntryPoint");
                }
                catch (Exception ex)
                {
                    Logger.Error($"é…ç½®åŠ è½½å¤±è´¥: {ex.Message}", "EntryPoint");
                    return;
                }
                
                try
                {
                    HookManager.Instance.InstallAll(config);
                    Logger.Info("Hookå®‰è£…å®Œæˆ", "EntryPoint");
                }
                catch (Exception ex)
                {
                    Logger.Error($"Hookå®‰è£…å¤±è´¥: {ex.Message}", "EntryPoint");
                    return;
                }
                
                try
                {
                    _unloadEvent = new EventWaitHandle(false, EventResetMode.ManualReset, unloadEventName);
                    Logger.Info($"å¸è½½äº‹ä»¶å·²åˆ›å»º: {unloadEventName}", "EntryPoint");
                }
                catch (Exception ex)
                {
                    Logger.Error($"å¸è½½äº‹ä»¶åˆ›å»ºå¤±è´¥: {ex.Message}", "EntryPoint");
                    return;
                }
                
                Logger.Info("ç­‰å¾…å¸è½½ä¿¡å·...", "EntryPoint");
                _unloadEvent.WaitOne();
                
                Logger.Info("æ”¶åˆ°å¸è½½ä¿¡å·ï¼Œå¼€å§‹æ¸…ç†", "EntryPoint");
            }
            catch (Exception ex)
            {
                Logger.Error($"EntryPointè¿è¡Œå¼‚å¸¸: {ex.Message}\n{ex.StackTrace}", "EntryPoint");
            }
            finally
            {
                Cleanup();
            }
        }
        
        private void Cleanup()
        {
            try
            {
                HookManager.Instance.UninstallAll();
                Logger.Info("Hookå·²å¸è½½", "EntryPoint");
            }
            catch (Exception ex)
            {
                Logger.Error($"Hookå¸è½½å¤±è´¥: {ex.Message}", "EntryPoint");
            }
            
            _unloadEvent?.Dispose();
            
            Logger.Flush();
            Logger.Info("EntryPoint.Runç»“æŸ", "EntryPoint");
        }
    }
}
```

---

## ğŸ“… åç»­ä¿®å¤è®¡åˆ’

### ç¬¬äºŒæœŸä¿®å¤ï¼ˆé…ç½®æ–‡ä»¶åŠ å¯†ï¼‰

å®ç°AES-256é…ç½®æ–‡ä»¶åŠ å¯†ï¼š

```csharp
public static class ConfigEncryption
{
    private static readonly byte[] Key = new byte[32]; // 256-bit key
    private static readonly byte[] IV = new byte[16];  // 128-bit IV
    
    public static string Encrypt(string plainText)
    {
        using (var aes = Aes.Create())
        {
            aes.Key = Key;
            aes.IV = IV;
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;
            
            using (var encryptor = aes.CreateEncryptor())
            using (var ms = new MemoryStream())
            {
                using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                using (var sw = new StreamWriter(cs))
                {
                    sw.Write(plainText);
                }
                return Convert.ToBase64String(ms.ToArray());
            }
        }
    }
}
```

### ç¬¬ä¸‰æœŸä¿®å¤ï¼ˆè¿›ç¨‹ç›‘æ§ï¼‰

å®ç°è¿›ç¨‹å¥åº·ç›‘æ§å’Œè‡ªåŠ¨é‡æ–°æ³¨å…¥ï¼š

```csharp
public class ProcessMonitor
{
    private readonly Dictionary<int, ProcessInfo> _monitoredProcesses = new Dictionary<int, ProcessInfo>();
    private readonly Timer _checkTimer;
    
    public ProcessMonitor()
    {
        _checkTimer = new Timer(CheckProcesses, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
    }
    
    private void CheckProcesses(object state)
    {
        lock (_monitoredProcesses)
        {
            foreach (var processId in _monitoredProcesses.Keys.ToList())
            {
                if (!IsProcessAlive(processId))
                {
                    HandleProcessExit(processId);
                }
            }
        }
    }
}
```

---

## ğŸ§ª éªŒè¯æ­¥éª¤

ä¿®å¤åï¼Œè¯·æŒ‰ä»¥ä¸‹æ­¥éª¤éªŒè¯ï¼š

1. **ç¼–è¯‘éªŒè¯**
   ```bash
   dotnet build Buddy_Code/HardwareHook.sln
   ```
   ç¡®ä¿æ— ç¼–è¯‘é”™è¯¯

2. **å•å…ƒæµ‹è¯•**
   - æµ‹è¯•ConfigManageré…ç½®åŠ è½½
   - æµ‹è¯•Loggerå¼‚æ­¥å†™å…¥
   - æµ‹è¯•HookManagerå®ä¾‹åˆ›å»º

3. **é›†æˆæµ‹è¯•**
   - å¯åŠ¨ä¸»ç¨‹åºï¼ŒåŠ è½½è¿›ç¨‹åˆ—è¡¨
   - é€‰æ‹©notepad.exeå¹¶æ³¨å…¥
   - è¿è¡ŒHWInfoTest.exeéªŒè¯ç¡¬ä»¶ä¿¡æ¯
   - éªŒè¯æ—¥å¿—æ–‡ä»¶æ ¼å¼

4. **æ€§èƒ½æµ‹è¯•**
   - æµ‹é‡Hookå›è°ƒæ‰§è¡Œæ—¶é—´ï¼ˆåº”<1msï¼‰
   - æµ‹é‡æ³¨å…¥è€—æ—¶ï¼ˆåº”<500msï¼‰
   - ç›‘æ§ç›®æ ‡è¿›ç¨‹CPUä½¿ç”¨ç‡ï¼ˆå¢åŠ åº”<1%ï¼‰

---

**ä¿®å¤å®Œæˆæ—¶é—´é¢„ä¼°**: 3-5å¤©
**éªŒè¯æ—¶é—´é¢„ä¼°**: 2-3å¤©
