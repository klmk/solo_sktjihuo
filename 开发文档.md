# Windows硬件信息模拟Hook工具开发文档

## 一、项目现状分析

### 1.1 项目结构

当前项目采用双程序架构：

| 程序名称 | 类型 | 核心作用 | 状态 |
|---------|------|---------|------|
| 硬件信息模拟Hook工具（主程序） | WinForm可视化应用 | 核心操作端：进程选择、DLL注入、Hook管理、状态展示、日志查看 | 已实现 |
| 硬件信息测试程序 | 控制台应用 | 验证端：采集硬件信息、对比Hook前后结果、支持命令行调用 | 已实现 |
| Hook核心DLL | 类库 | 实现API拦截和硬件信息模拟 | 部分实现 |
| 硬件信息获取测试App | 控制台应用 | 专门用于测试硬件信息模拟效果的应用程序 | 待开发 |

### 1.2 已实现功能

- ✅ 硬件信息读取与配置导出
- ✅ 进程列表加载与刷新
- ✅ DLL注入基础框架
- ✅ 核心API Hook实现（CPU/硬盘/MAC/注册表）
- ✅ 可视化操作界面
- ✅ 基础日志系统
- ✅ 测试程序

### 1.3 待完善功能

- ❌ 硬件信息获取测试App开发
- ❌ 设备参数获取功能完善
- ❌ Hook功能稳定性优化
- ❌ w3wp.exe（IIS进程）适配
- ❌ 全程序支持（扩展到所有Windows进程）
- ❌ 注入切入点优化
- ❌ 完整的测试验证流程
- ❌ 异常处理与边界情况
- ❌ 性能优化

## 二、开发环境要求

### 2.1 系统要求

- **操作系统**：Windows 7/8/10/11 x64 系统
- **运行时**：.NET Framework 4.8
- **权限**：管理员权限（必须，以确保能够注入所有进程）

### 2.2 开发工具

- Visual Studio 2019 或更高版本
- .NET Framework 4.8 开发工具包
- NuGet 包管理器

### 2.3 依赖项

| 依赖项 | 版本 | 用途 |
|-------|------|------|
| EasyHook | 2.6.6 | DLL注入和API Hook框架 |
| Newtonsoft.Json | 13.0.1 | JSON配置文件处理 |
| 0Harmony | 2.2.2 | 内存补丁（可选） |

### 2.4 硬件信息获取测试App开发计划

#### 2.4.1 测试App功能

1. **全面硬件信息采集**：
   - CPU信息：型号、核心数、CPUID
   - 硬盘信息：序列号、型号、容量
   - 网卡信息：MAC地址、IP地址
   - 主板信息：序列号、型号
   - BIOS信息：版本、发布日期
   - 内存信息：容量、频率
   - 显卡信息：型号、显存

2. **多方式采集**：
   - 原生API采集
   - WMI采集
   - 注册表采集

3. **测试功能**：
   - 定时采集（模拟持续运行的应用场景）
   - 输出格式可配置（文本/JSON）
   - 支持命令行参数

#### 2.4.2 测试App开发步骤

1. **项目创建**：
   - 创建控制台应用项目
   - 配置为.NET Framework 4.8 x64

2. **核心功能实现**：
   - 硬件信息采集模块
   - 多方式采集实现
   - 数据输出模块

3. **测试验证**：
   - 验证采集数据的准确性
   - 验证与主程序的兼容性
   - 验证在Hook前后的行为差异

## 三、核心功能实现指南

### 3.1 API Hook实现

#### 3.1.1 Hook安装流程

1. **DLL注入**：使用EasyHook的`RemoteHooking.Inject`方法将核心DLL注入目标进程
2. **入口点初始化**：`EntryPoint.Run`方法被调用，加载配置文件
3. **Hook安装**：调用`HookManager.InstallAll`安装所有API Hook
4. **等待卸载信号**：创建事件等待句柄，等待卸载信号

#### 3.1.2 核心API拦截

| API类别 | 拦截的API | 实现文件 | 功能 |
|--------|----------|---------|------|
| CPU/系统 | GetSystemInfo, GetNativeSystemInfo | CpuSystemHooks.cs | 模拟CPU核心数等信息 |
| 硬盘 | GetVolumeInformationW, DeviceIoControl | DiskHooks.cs | 模拟硬盘序列号等信息 |
| 网卡/MAC | GetAdaptersInfo, GetIfTable | MacHooks.cs | 模拟MAC地址 |
| 主板/BIOS | RegOpenKeyEx, RegQueryValueEx | RegistryHooks.cs | 模拟主板序列号等信息 |

#### 3.1.3 Hook回调函数设计

```csharp
private static void GetSystemInfo_Detour(out NativeApi.SYSTEM_INFO lpSystemInfo)
{
    // 先调用原始API，获取真实信息
    _origGetSystemInfo(out lpSystemInfo);
    
    try
    {
        // 检查是否在Capture模式
        if (CaptureStore.IsCaptureMode)
        {
            // 记录原始值
            var obj = new { dwNumberOfProcessors = lpSystemInfo.dwNumberOfProcessors };
            CaptureStore.Record(IdentityGetSystemInfo, "Win32", "kernel32.dll", "GetSystemInfo", null, obj);
            return;
        }
        
        // 检查是否在Replay模式
        if (CaptureStore.IsReplayMode)
        {
            // 从记录中获取值并应用
            if (CaptureStore.TryGetReplaceValue(IdentityGetSystemInfo, out var token))
            {
                ApplySystemInfoToken(token, ref lpSystemInfo);
                return;
            }
        }
        
        // 应用配置中的值
        if (_config?.Cpu != null)
        {
            lpSystemInfo.dwNumberOfProcessors = (uint)Math.Max(1, _config.Cpu.CoreCount);
        }
    }
    catch (Exception ex)
    {
        // 异常处理，确保目标进程不崩溃
        LogHelper.Write("GetSystemInfo_Detour 异常: " + ex.Message);
    }
}
```

### 3.2 配置管理

#### 3.2.1 配置文件结构

```json
{
  "Mode": "Normal", // Normal, Capture, Replay
  "Cpu": {
    "Model": "Intel(R) Core(TM) i9-12900K",
    "CoreCount": 16,
    "CpuId": "BFEBFBFF000A06E9"
  },
  "Disk": {
    "Serial": "1234567890ABCDEF"
  },
  "Mac": {
    "Address": "00:11:22:33:44:55"
  },
  "Motherboard": {
    "Serial": "MB-2025-12345678"
  }
}
```

#### 3.2.2 配置加载与验证

```csharp
public static HardwareConfig Load(string path)
{
    if (string.IsNullOrEmpty(path) || !File.Exists(path))
        throw new FileNotFoundException("配置文件不存在", path);
    
    string json = File.ReadAllText(path, Encoding.UTF8);
    var config = JsonConvert.DeserializeObject<HardwareConfig>(json);
    Validate(config);
    return config;
}

public static void Validate(HardwareConfig config)
{
    if (config == null)
        throw new ArgumentNullException(nameof(config));
    
    // 验证核心配置项
    if (config.Cpu != null && config.Cpu.CoreCount < 1)
        config.Cpu.CoreCount = 1;
}
```

### 3.3 DLL注入实现

#### 3.3.1 注入切入点优化

**核心切入点策略**：

1. **双重Hook策略**：
   - **系统核心DLL**：拦截kernel32.dll、advapi32.dll等系统核心DLL中的硬件信息相关API
   - **.NET平台DLL**：拦截mscorlib.dll、System.Management.dll等.NET平台DLL中的硬件配置获取方法

2. **优先级设计**：
   - 系统核心DLL Hook优先级最高，确保底层API被拦截
   - .NET平台DLL Hook作为补充，确保C#应用程序也能被正确拦截

3. **稳定注入保障**：
   - 采用EasyHook框架的RemoteHooking.Inject方法
   - 支持32位和64位进程
   - 注入前进行进程兼容性检查

#### 3.3.2 注入流程

1. **验证目标进程**：检查进程是否存活
2. **验证配置文件**：确保配置文件有效
3. **解析核心DLL路径**：找到HardwareHook.Core.dll
4. **生成卸载事件名称**：用于后续卸载Hook
5. **执行注入**：使用EasyHook的RemoteHooking.Inject方法

```csharp
public InjectResult Inject(int processId, string configPath)
{
    lock (Lock)
    {
        if (!ProcessAlive(processId))
            return InjectResult.Fail("目标进程不存在或已退出");
        
        if (string.IsNullOrWhiteSpace(configPath) || !File.Exists(configPath))
            return InjectResult.Fail("配置文件无效");
        
        try
        {
            ConfigManager.Validate(ConfigManager.Load(configPath));
        }
        catch (Exception ex)
        {
            return InjectResult.Fail("配置文件格式错误：" + ex.Message);
        }
        
        string dllPath = ResolveCoreDllPath();
        if (string.IsNullOrEmpty(dllPath))
            return InjectResult.Fail("找不到 Hook 核心 DLL");
        
        string unloadEventName = "HardwareHook_Unload_" + processId;
        try
        {
            RemoteHooking.Inject(
                processId,
                InjectionOptions.Default,
                dllPath,
                dllPath,
                configPath,
                unloadEventName
            );
            return InjectResult.Ok(unloadEventName);
        }
        catch (Exception ex)
        {
            return InjectResult.Fail("注入失败：" + ex.Message);
        }
    }
}
```

#### 3.3.2 卸载流程

1. **生成卸载事件名称**：与注入时使用的名称对应
2. **设置事件信号**：通知目标进程中的Hook卸载

```csharp
public void StopSimulation(int processId)
{
    string evtName = "HardwareHook_Unload_" + processId;
    try
    {
        using (var evt = new EventWaitHandle(false, EventResetMode.ManualReset, evtName))
        {
            evt.Set();
        }
    }
    catch { }
}
```

## 四、测试策略

### 4.1 测试工具

1. **硬件信息获取测试App**：专门用于测试硬件信息模拟效果的综合测试应用
2. **硬件信息测试程序（HWInfoTest.exe）**：用于快速验证硬件信息模拟效果
3. **AppTest.exe**：用于模拟应用程序场景

### 4.2 硬件信息获取测试App测试计划

#### 4.2.1 功能测试

1. **全面硬件信息采集测试**：
   - 验证所有硬件信息的采集功能
   - 验证多方式采集的一致性
   - 验证采集数据的准确性

2. **Hook效果测试**：
   - 测试在Hook前后的硬件信息变化
   - 测试不同Hook模式的效果
   - 测试持续运行时的Hook稳定性

3. **边界情况测试**：
   - 测试硬件信息异常的处理
   - 测试资源占用情况
   - 测试长时间运行的稳定性

#### 4.2.2 与主程序集成测试

1. **注入流程测试**：
   - 测试主程序对测试App的注入
   - 测试注入后的Hook效果
   - 测试注入失败的处理

2. **配置文件测试**：
   - 测试配置文件的加载和应用
   - 测试不同配置的效果
   - 测试配置文件错误的处理

3. **卸载流程测试**：
   - 测试Hook的卸载
   - 测试卸载后硬件信息的恢复
   - 测试卸载失败的处理

### 4.3 主程序测试流程

#### 4.3.1 基础功能测试

1. **硬件信息读取测试**：
   - 点击"读取硬件信息"按钮
   - 验证界面显示的硬件信息是否正确
   - 验证日志记录是否完整

2. **配置导出测试**：
   - 读取硬件信息后，点击"导出配置模板"
   - 验证导出的JSON文件格式是否正确
   - 验证配置文件内容是否与读取的硬件信息一致

3. **进程管理测试**：
   - 点击"刷新进程列表"
   - 验证进程列表是否正确显示
   - 验证进程状态显示是否正确

4. **DLL注入测试**：
   - 选择一个测试进程（如notepad.exe）
   - 选择配置文件
   - 点击"模拟"按钮
   - 验证注入是否成功
   - 验证进程状态是否更新为"模拟中"
   - 验证进程DLL列表中是否包含HardwareHook.Core.dll

5. **Hook功能测试**：
   - 注入成功后，运行HWInfoTest.exe
   - 验证测试程序显示的硬件信息是否与配置文件一致
   - 对比注入前后的硬件信息

6. **卸载测试**：
   - 点击"停止模拟"按钮
   - 验证进程状态是否更新为"未模拟"
   - 再次运行HWInfoTest.exe，验证硬件信息是否恢复真实值

#### 4.3.2 w3wp.exe适配测试

1. **IIS启动测试**：
   - 确保IIS服务已启动
   - 验证w3wp.exe进程是否存在

2. **权限测试**：
   - 以管理员身份运行主程序
   - 尝试注入w3wp.exe进程
   - 验证注入是否成功

3. **功能测试**：
   - 注入w3wp.exe后，访问IIS托管的网站
   - 验证网站是否能正常运行
   - 验证硬件信息模拟是否生效

4. **稳定性测试**：
   - 持续访问网站，验证w3wp.exe是否稳定运行
   - 验证Hook是否持续有效

### 4.4 测试用例

| 测试用例 | 预期结果 | 验证方法 |
|---------|---------|----------|
| 模拟CPU核心数 | HWInfoTest显示配置的核心数 | 运行HWInfoTest.exe --cpu |
| 模拟硬盘序列号 | HWInfoTest显示配置的序列号 | 运行HWInfoTest.exe --disk |
| 模拟MAC地址 | HWInfoTest显示配置的MAC地址 | 运行HWInfoTest.exe --mac |
| 模拟主板序列号 | HWInfoTest显示配置的序列号 | 运行HWInfoTest.exe --bios |
| 注入notepad.exe | 注入成功，状态更新为"模拟中" | 查看进程状态和DLL列表 |
| 注入w3wp.exe | 注入成功，IIS网站正常运行 | 访问IIS网站并验证硬件信息 |
| 卸载Hook | 状态更新为"未模拟"，硬件信息恢复真实值 | 再次运行HWInfoTest.exe |

## 五、常见问题与解决方案

### 5.1 注入失败

| 错误信息 | 可能原因 | 解决方案 |
|---------|---------|----------|
| 目标进程不存在或已退出 | 进程已结束 | 确认进程是否存活，重新选择进程 |
| 配置文件无效 | 配置文件不存在或格式错误 | 选择有效的配置文件，确保JSON格式正确 |
| 找不到Hook核心DLL | DLL文件不存在 | 确保HardwareHook.Core.dll在正确位置 |
| 注入失败：拒绝访问 | 权限不足 | 以管理员身份运行主程序 |
| 注入失败：无法打开进程 | 进程权限过高 | 尝试注入普通用户进程，w3wp.exe需要特殊处理 |

### 5.2 Hook功能未生效

| 问题现象 | 可能原因 | 解决方案 |
|---------|---------|----------|
| 硬件信息未改变 | Hook未成功安装 | 检查日志，确认Hook安装是否成功 |
| 部分硬件信息未改变 | 对应的API未被调用 | 使用测试程序验证，或检查目标程序使用的API |
| Hook生效后又恢复 | Hook被其他程序覆盖 | 检查是否有其他Hook工具，确保我们的Hook优先级更高 |

### 5.3 稳定性问题

| 问题现象 | 可能原因 | 解决方案 |
|---------|---------|----------|
| 目标进程崩溃 | Hook回调函数异常未捕获 | 确保所有Hook回调函数都有try-catch |
| 主程序崩溃 | 未处理异常 | 确保主程序中的所有操作都有异常处理 |
| 注入后目标进程无响应 | Hook回调函数执行时间过长 | 优化Hook回调函数，避免耗时操作 |

## 六、全进程适配指南

### 6.1 进程适配范围

- **核心目标**：w3wp.exe（IIS进程）适配
- **扩展目标**：所有Windows用户进程和系统进程
- **优先级**：先实现w3wp.exe适配，再扩展到其他进程

### 6.2 w3wp.exe特性

- **运行身份**：通常以应用池身份运行，权限较低
- **保护机制**：IIS可能会对w3wp.exe进程有特殊保护
- **生命周期**：应用池回收时会重启w3wp.exe进程
- **多进程**：多个应用池会对应多个w3wp.exe进程

### 6.3 设备参数获取完善

1. **扩展硬件信息采集**：
   - CPU：型号、核心数、线程数、主频、缓存
   - 硬盘：序列号、型号、容量、接口类型、转速
   - 网卡：MAC地址、IP地址、厂商、型号
   - 主板：序列号、型号、厂商、芯片组
   - BIOS：版本、发布日期、厂商
   - 内存：容量、频率、厂商、型号
   - 显卡：型号、显存、厂商、驱动版本

2. **多方式采集实现**：
   - 原生API采集：确保兼容性和性能
   - WMI采集：获取更详细的硬件信息
   - 注册表采集：获取系统配置信息
   - 直接硬件访问：获取底层硬件参数

3. **参数验证与标准化**：
   - 验证采集数据的准确性
   - 标准化数据格式
   - 处理异常情况和边界值

### 6.4 w3wp.exe适配策略

1. **权限提升**：
   - 以管理员身份运行主程序
   - 确保主程序具有足够的权限注入w3wp.exe

2. **进程识别**：
   - 通过命令行参数或环境变量识别w3wp.exe进程
   - 区分不同应用池的w3wp.exe进程

3. **注入时机**：
   - 选择在应用池稳定运行后进行注入
   - 避免在应用池启动或回收过程中注入

4. **稳定性保障**：
   - 优化Hook回调函数，确保执行速度快
   - 增加异常处理，确保w3wp.exe不崩溃
   - 监控w3wp.exe进程状态，及时处理异常情况

5. **应用池回收处理**：
   - 监控应用池回收事件
   - 在应用池回收后重新注入

### 6.3 具体实现

1. **w3wp.exe进程识别**：

```csharp
private static bool IsW3wpProcess(Process process)
{
    return process.ProcessName.Equals("w3wp", StringComparison.OrdinalIgnoreCase);
}

private static string GetAppPoolName(Process process)
{
    try
    {
        // 通过命令行参数获取应用池名称
        foreach (var arg in process.StartInfo.Arguments.Split(' '))
        {
            if (arg.StartsWith("-ap"))
            {
                return arg.Substring(3);
            }
        }
        return "Unknown";
    }
    catch
    {
        return "Unknown";
    }
}
```

2. **w3wp.exe注入优化**：

```csharp
public InjectResult InjectW3wp(int processId, string configPath)
{
    // 验证进程是否为w3wp.exe
    Process process;
    try
    {
        process = Process.GetProcessById(processId);
        if (!IsW3wpProcess(process))
        {
            return InjectResult.Fail("目标进程不是w3wp.exe");
        }
    }
    catch
    {
        return InjectResult.Fail("无法获取进程信息");
    }
    
    // 记录应用池名称
    string appPoolName = GetAppPoolName(process);
    LogHelper.Write("注入w3wp.exe进程，应用池：" + appPoolName);
    
    // 执行注入
    return Inject(processId, configPath);
}
```

3. **应用池回收监控**：

```csharp
private void MonitorAppPoolRecycle()
{
    // 定期检查w3wp.exe进程
    Timer timer = new Timer(TimerCallback, null, 0, 30000); // 每30秒检查一次
}

private void TimerCallback(object state)
{
    try
    {
        // 获取所有w3wp.exe进程
        var w3wpProcesses = Process.GetProcessesByName("w3wp");
        
        // 检查是否有新的w3wp.exe进程
        foreach (var process in w3wpProcesses)
        {
            if (!_injectedProcesses.Contains(process.Id))
            {
                // 新的w3wp.exe进程，需要重新注入
                LogHelper.Write("检测到新的w3wp.exe进程，PID：" + process.Id);
                // 执行注入逻辑
            }
        }
        
        // 移除已结束的进程
        _injectedProcesses.RemoveAll(pid => !ProcessAlive(pid));
    }
    catch (Exception ex)
    {
        LogHelper.Write("监控应用池回收异常：" + ex.Message);
    }
}
```

## 七、开发流程与注意事项

### 7.1 开发流程

1. **环境搭建**：
   - 安装Visual Studio 2019或更高版本
   - 安装.NET Framework 4.8开发工具包
   - 克隆项目代码
   - 还原NuGet包

2. **代码编译**：
   - 设置解决方案配置为Debug
   - 设置平台目标为x64
   - 构建解决方案

3. **测试验证**：
   - 运行主程序
   - 执行基础功能测试
   - 执行w3wp.exe适配测试
   - 验证所有功能是否正常

4. **性能优化**：
   - 分析Hook回调函数执行时间
   - 优化内存使用
   - 减少日志写入频率

5. **稳定性测试**：
   - 长时间运行测试
   - 压力测试
   - 异常场景测试

### 7.2 注意事项

1. **权限问题**：
   - 始终以管理员身份运行主程序
   - 确保目标进程权限低于或等于主程序权限

2. **稳定性问题**：
   - 所有Hook回调函数必须包裹try-catch
   - 避免在Hook回调中执行耗时操作
   - 避免在Hook回调中访问UI
   - 使用异步日志写入

3. **内存管理**：
   - 避免内存泄漏
   - 及时释放不再使用的资源
   - 使用SafeMemory工具类处理内存操作

4. **重复操作防护**：
   - 避免重复注入同一进程
   - 避免重复卸载未注入的进程
   - 按钮状态联动，避免无效操作

5. **配置文件管理**：
   - 确保配置文件格式正确
   - 验证配置文件内容有效性
   - 处理配置文件不存在的情况

6. **日志管理**：
   - 记录足够的日志信息
   - 避免日志过多影响性能
   - 日志分级，便于问题排查

7. **w3wp.exe特殊处理**：
   - 注意应用池回收问题
   - 确保w3wp.exe稳定运行
   - 监控w3wp.exe进程状态

## 八、总结与后续计划

### 8.1 项目总结

当前项目已经实现了Windows硬件信息模拟Hook工具的核心功能，包括：

- 硬件信息读取与配置导出
- 进程管理与DLL注入
- API Hook实现（CPU/硬盘/MAC/注册表）
- 可视化操作界面
- 基础日志系统
- 测试程序

项目架构清晰，代码组织合理，已经具备了基本的硬件信息模拟能力。

### 8.2 后续开发计划

#### 8.2.1 第一阶段：核心功能完善

1. **硬件信息获取测试App开发**：
   - 实现全面的硬件信息采集功能
   - 支持多方式采集（原生API、WMI、注册表）
   - 提供丰富的测试功能

2. **设备参数获取完善**：
   - 扩展硬件信息采集范围
   - 支持更多硬件参数的模拟
   - 确保参数获取的准确性和完整性

3. **注入切入点优化**：
   - 实现双重Hook策略（系统核心DLL + .NET平台DLL）
   - 优化Hook优先级设计
   - 提高注入稳定性

#### 8.2.2 第二阶段：w3wp.exe适配

1. **w3wp.exe特性适配**：
   - 解决权限问题
   - 处理应用池回收
   - 确保IIS网站稳定运行

2. **w3wp.exe测试验证**：
   - 功能测试
   - 性能测试
   - 稳定性测试

#### 8.2.3 第三阶段：全进程适配扩展

1. **进程类型适配**：
   - 用户进程适配
   - 系统进程适配
   - 特权进程适配

2. **自动化适配**：
   - 进程重启后自动重新注入
   - 适配策略自动选择
   - 异常情况自动处理

#### 8.2.4 性能与稳定性优化

1. **性能优化**：
   - 减少Hook回调函数执行时间
   - 优化内存使用
   - 提高注入速度

2. **稳定性优化**：
   - 增强异常处理
   - 提高Hook稳定性
   - 优化资源管理

#### 8.2.5 测试与文档完善

1. **测试覆盖**：
   - 增加自动化测试
   - 增加更多测试场景
   - 提高测试覆盖率

2. **文档完善**：
   - 编写用户手册
   - 编写API文档
   - 编写故障排查指南

3. **用户体验改进**：
   - 改进界面设计
   - 增加配置文件管理功能
   - 增加批量操作功能

### 8.3 开发建议

1. **循序渐进**：先确保基础功能稳定，再进行高级功能开发
2. **注重测试**：每个功能开发完成后，立即进行测试验证
3. **代码质量**：保持代码整洁，添加必要的注释
4. **团队协作**：明确分工，定期沟通开发进度
5. **用户反馈**：及时收集用户反馈，持续改进产品

---

**开发团队注意事项**：

1. 开发过程中严格遵循本文档的指导
2. 遇到问题时，参考"常见问题与解决方案"部分
3. 开发完成后，执行完整的测试流程
4. 确保代码符合项目的代码规范
5. 定期更新开发文档，记录开发过程中的重要变更

---

**最后更新时间**：2026年2月25日